#' A "glassbox" pipeline wrapper for `eyeris`
#'
#' This `glassbox` function (in contrast to a "blackbox" function where you run
#' it and get a result but have no (or little) idea as to how you got from input
#' to output) has a few primary benefits over calling each exported function
#' from `eyeris` separately.
#'
#' First, this `glassbox` function provides a highly opinionated prescription of
#' steps and starting parameters we believe any pupillometry researcher should
#' use as their defaults when preprocessing pupillometry data.
#'
#' Second, and not mutually exclusive from the first point, using this function
#' should ideally reduce the probability of accidental mishaps when
#' "reimplementing" the steps from the preprocessing pipeline both within and
#' across projects. We hope to streamline the process in such a way that you
#' could collect a pupillometry dataset and within a few minutes assess the
#' quality of those data while simultaneously running a full preprocessing
#' pipeline in 1-ish line of code!
#'
#' Third, `glassbox` provides an "interactive" framework where you can evaluate
#' the consequences of the parameters within each step on your data in real
#' time, facilitating a fairly easy-to-use workflow for parameter optimization
#' on your particular dataset. This process essentially takes each of the
#' opinionated steps and provides a pre-/post-plot of the timeseries data for
#' each step so you can adjust parameters and re-run the pipeline until you are
#' satisfied with the choices of your paramters and their consequences on your
#' pupil timeseries data.
#'
#' @param file An SR Research EyeLink `.asc` file generated by the official
#' EyeLink `edf2asc` command.
#' @param interactive A flag to indicate whether to run the `glassbox` pipeline
#' autonomously all the way through (set to `FALSE`, the default), or to
#' interactively provide a visualization after each pipeline step, where you
#' must also indicate "(y)es" or "(n)o" to either proceed or cancel the
#' current `glassbox` pipeline operation (set to `TRUE`).
#' @param n_epochs Number of random epochs to generate for visualization.
#' @param duration Time in seconds of each randomly selected epoch.
#' @param time_range The start and stop raw timestamps used to subset the
#' preprocessed data from each step of the `eyeris` pipeline for visualization.
#' Defaults to NULL, meaning random epochs as defined by `n_epochs` and
#' `duration` will be plotted. To override the random epochs, set `time_range`
#' here to a vector with relative start and stop times (e.g., `c(5000, 6000)`
#' to indicate the raw data from 5-6 seconds on data that were recorded at
#' 1000 Hz).
#' @param ... Additional arguments to override the default, prescribed settings.
#'
#' @examples
#' \dontrun{
#' demo_data <- system.file("extdata", "assocret.asc", package = "eyeris")
#'
#' # (1) examples using the default prescribed parameters and pipeline recipe
#' ## (a) run an automated pipeline with no real-time inspection of parameters
#' output <- eyeris::glassbox(demo_data)
#'
#' ## (b) run an interactive pipeline
#' output <- eyeris::glassbox(demo_data, interactive = TRUE)
#'
#' # (2) examples overriding the default parameters
#' output <- eyeris::glassbox(demo_data,
#'   interactive = TRUE,
#'   deblink = list(extend = 40),
#'   lpfilt = list(plot_freqz = FALSE)
#' )
#' }
#'
#' @export
glassbox <- function(file, interactive = FALSE, n_epochs = 3, duration = 5,
                     time_range = NULL, ...) {

  # the default parameters
  params <- list(
    deblink = list(extend = 50),
    detransient = list(n = 16),
    lpfilt = list(wp = 4, ws = 8, rp = 1, rs = 35, plot_freqz = TRUE),
    zscore = list(groups = NULL)
  )

  params <- utils::modifyList(params, list(...))

  pipeline <- list(
    load = function(data, params) {
      return(eyeris::load_asc(data))
    },
    deblink = function(data, params) {
      return(eyeris::deblink(data, extend = params$deblink$extend))
    },
    detransient = function(data, params) {
      return(eyeris::detransient(data, n = params$detransient$n))
    },
    interpolate = function(data, params) {
      return(eyeris::interpolate(data))
    },
    lpfilt = function(data, params) {
      return(eyeris::lpfilt(data,
        wp = params$lpfilt$wp,
        ws = params$lpfilt$ws,
        rp = params$lpfilt$rp,
        rs = params$lpfilt$rs,
        plot_freqz = params$lpfilt$plot_freqz
      ))
    },
    detrend = function(data, params) {
      return(eyeris::detrend(data))
    },
    zscore = function(data, params) {
      return(eyeris::zscore(data, groups = params$zscore$groups))
    }
  )

  for (step_name in names(pipeline)) {
    cli::cli_alert(
      paste("Running", step_name, "...")
    )

    step_to_run <- pipeline[[step_name]]
    err_thrown <- FALSE
    file <- tryCatch(
      {
        step_to_run(file, params)
      },
      error = function(e) {
        cli::cli_alert_info(
          paste("Skipping", step_name, ":", e$message, "\n")
        )
        cat("\n")
        err_thrown <<- TRUE
        return(file)
      }
    )

    if (interactive) {
      if (!err_thrown) {
        plot(file, time_range = time_range)
        if (step_name != "zscore") {
          if (!prompt_user()) {
            cli::cli_alert_info(
              paste(
                "Process cancelled after running the", step_name, "step.",
                "Adjust your parameters and re-run!"
              )
            )

            break
          }

          cat("\n")
        }
      }
    }
  }

  return(file)
}

prompt_user <- function() {
  resp <- readline(prompt = "Continue? [Yes/No]: ")
  return(tolower(resp) == "yes" | tolower(resp) == "y")
}
